## Switch

[[Defer] https://go.dev/tour/flowcontrol/12](https://go.dev/tour/flowcontrol/12)

[[Stacking defers] https://go.dev/tour/flowcontrol/13](https://go.dev/tour/flowcontrol/13)

> The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.

The page includes the note above but the example on the page does not reflect the essence of this warning. A more appropriate example would be like the following.
```go
package main

import "fmt"

func main() {
	message := "world"
	defer fmt.Println(message)
	message = "hello"
	fmt.Println(message)
}
```
```
hello
world

Program exited.
```
[Run on Go Playground](https://go.dev/play/p/Eid3X3-iCqM)

As you can see in the output, although the `defer fmt.Println(message)` statement is executed just before leaving the `main()` function's scope, the value of the variable `message` evaluated where the `defer` statement actually sits in the code.

If defer just postpones the execution of the statement why use defer instead of putting it just before the curly bracket? Having multiple return statements within a function is idiomatic. So there's usually no guarantee that the flow of the product's execution reach the line just before the curly bracket. Think of a function where you query your database to find a record. The best case flow of this function would be like this:
- Open a connection to the database
- Make your query
- Close the database connection
- Return the record.

But lots of things may go wrong with a database connection. You'll want to catch any errors returning from the query method and return prematurely. But you'll always want to close the connection to prevent spilling. Instead of adding the connection closing code to each and every possible return from the function, it's always better to defer once just after the opening of connection and stay safe. So a better flow would look like this:
- Open a connection to the database
- Check for error
  - If there's an error, return error
  - Else, defer closing connection
- Make your query
  - If there's and error return error
  - Else, do whatever you want to do with the record and return

### Panic
> Panic is a built-in function that stops the ordinary flow of control and begins panicking.

You probably saw some panics (hopefully not so often) from the standard library. When something happens which is not recoverable, e.g. divide by zero. Also, you can use `panic` keyword to cause panic on your program. You may be wondering why I brought up panics while talking about defer. It's essential to know that deferred statements will run even if the program panics.
```go
package main

import "fmt"

func main() {
	defer fmt.Println("Write this whatever happens")
	zero := 0
	t := 10 / zero // This line will cause panic
	fmt.Println(t)
}
```
```
Write this whatever happens
panic: runtime error: integer divide by zero

goroutine 1 [running]:
main.main()
	/tmp/sandbox3713112275/prog.go:8 +0x6c

Program exited.
```
[Run on Go Playground](https://go.dev/play/p/dUgsKth9uyL)

### Context
> [Package context](https://pkg.go.dev/context) defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.

---

| [Previous](9-10-11.md) | [Home](../../index.md) | [Next] |